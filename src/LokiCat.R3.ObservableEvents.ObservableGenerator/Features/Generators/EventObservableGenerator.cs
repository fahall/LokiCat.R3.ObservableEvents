using System.Linq;
using LokiCat.R3.ObservableEvents.ObservableGenerator.Features.SyntaxHelpers;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace LokiCat.R3.ObservableEvents.ObservableGenerator.Features.Generators;

/// <summary>
/// Generates R3 observables for C# interface events.
/// </summary>
[Generator]
public sealed class EventObservableGenerator : ISourceGenerator
{
    private const string DIAGNOSTIC_ID = "EVTOBS001";
    private const string DIAGNOSTIC_CATEGORY = "EventObservables";

    public void Initialize(GeneratorInitializationContext context) { }

    public void Execute(GeneratorExecutionContext context)
    {
        EmitEventObservableExtensions(context);

        var syntaxTrees = context.Compilation.SyntaxTrees;

        foreach (var tree in syntaxTrees)
        {
            ProcessTree(context, tree);
        }
    }

    private static void ProcessTree(GeneratorExecutionContext context, SyntaxTree tree)
    {
        var root = tree.GetRoot();

        // Look for event declarations (not Signal attributes anymore)
        var eventDeclarations = root
            .DescendantNodes()
            .OfType<EventDeclarationSyntax>();

        foreach (var eventDecl in eventDeclarations)
        {
            ProcessEvent(eventDecl, context, root);
        }
    }

    private static void ProcessEvent(EventDeclarationSyntax eventDecl, GeneratorExecutionContext context, SyntaxNode root)
    {
        var eventTypeName = eventDecl.Type.ToString(); // e.g., PauseMenu.MainMenuEventHandler
        var eventName = eventDecl.Identifier.Text;     // e.g., MainMenu

        // Try to find matching delegate type
        var delegateDecl = root
            .DescendantNodes()
            .OfType<DelegateDeclarationSyntax>()
            .FirstOrDefault(d => d.Identifier.Text == eventTypeName.Split('.').Last());

        if (delegateDecl is null)
        {
            // Optionally: emit a diagnostic about missing delegate, but safe to skip
            return;
        }

        var parameters = delegateDecl.ParameterList.Parameters;
        var paramCount = parameters.Count;

        if (paramCount > 5)
        {
            var diagnostic = Diagnostic.Create(
                new DiagnosticDescriptor(
                    DIAGNOSTIC_ID,
                    title: "Event has too many parameters",
                    messageFormat: "Event '{0}' has more than 5 parameters — observable not generated.",
                    category: DIAGNOSTIC_CATEGORY,
                    DiagnosticSeverity.Warning,
                    isEnabledByDefault: true),
                eventDecl.GetLocation(),
                eventName
            );
            context.ReportDiagnostic(diagnostic);
            return;
        }

        var paramTypes = parameters.Select(p => p.Type?.ToString() ?? "object").ToList();
        var observableType = paramTypes.Count switch
        {
            0 => "Unit",
            1 => paramTypes[0],
            2 => $"({paramTypes[0]}, {paramTypes[1]})",
            3 => $"({paramTypes[0]}, {paramTypes[1]}, {paramTypes[2]})",
            4 => $"({paramTypes[0]}, {paramTypes[1]}, {paramTypes[2]}, {paramTypes[3]})",
            5 => $"({paramTypes[0]}, {paramTypes[1]}, {paramTypes[2]}, {paramTypes[3]}, {paramTypes[4]})",
            _ => throw new System.InvalidOperationException()
        };

        var classDecl = eventDecl.Parent as InterfaceDeclarationSyntax;
        if (classDecl is null)
        {
            return;
        }

        var className = classDecl.Identifier.Text;
        var ns = Namespace.GetNamespace(classDecl);
        var code = GenerateObservablePropertyCode(ns, className, eventName, observableType);

        context.AddSource($"{className}.On{eventName}.g.cs", code);
    }

    private static string GenerateObservablePropertyCode(string ns, string className, string eventName, string observableType)
    {
        var fieldName = $"_on{eventName}";
        var propertyName = $"On{eventName}";

        return $$$"""
                  // <auto-generated />
                  using System;
                  using R3;
                  using LokiCat.R3.ObservableEvents;
                  
                  namespace {{ns}};
                  
                  public partial interface {{className}} {
                      private Observable<{{observableType}}> {{fieldName}} = {{observableDefault}};
                      public Observable<{{observableType}}> {{propertyName}} => {{fieldName}};
                  }
                  """;
    }

    private static void EmitEventObservableExtensions(GeneratorExecutionContext context)
    {
        EventObservableExtensionGenerator.EmitSignalObservableExtensions(context);
    }
}